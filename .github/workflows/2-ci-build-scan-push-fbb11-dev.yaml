name: "CI/CD Pipeline - fbb11 (dev)"

on:
  push:
    branches:
      - main
    paths-ignore:
      - '.opsera-**/**'
      - '.github/workflows/1-bootstrap-*.yaml'
      - '.github/workflows/90-deployment-landscape-*.yaml'
      - '**/*.md'

  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even if no code changes'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

env:
  APP_NAME: fbb11
  TENANT: opsera
  ENVIRONMENT: dev
  AWS_REGION: us-west-2
  HUB_CLUSTER: argocd-usw2
  SPOKE_CLUSTER: opsera-usw2-np
  ARGOCD_SERVER: argocd-usw2.agent.opsera.dev
  ECR_REPO_NAME: opsera/fbb11
  NAMESPACE: opsera-fbb11-dev

permissions:
  contents: write
  id-token: write
  security-events: write

concurrency:
  group: ci-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

jobs:
  # Stage 1: Security Scan (Gitleaks)
  security-scan:
    name: "ðŸ”’ Security Scan (Gitleaks)"
    runs-on: ubuntu-latest
    continue-on-error: true  # Warn mode by default for Quick Setup
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Gitleaks
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Display scan mode
        if: always()
        run: |
          echo "âš ï¸  WARN MODE: Secrets detected but workflow continues"
          echo "To enable blocking mode, set GitHub variable GITLEAKS_MODE=block"

  # Stage 2: Build Image
  build-image:
    name: "ðŸ—ï¸ Build Docker Image"
    runs-on: ubuntu-latest
    needs: [security-scan]
    if: success() || failure()
    outputs:
      image_tag: ${{ steps.meta.outputs.image_tag }}
      image_name: ${{ steps.meta.outputs.image_name }}
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Generate image metadata
        id: meta
        run: |
          IMAGE_TAG="dev-${GITHUB_SHA:0:8}-$(date +%Y%m%d%H%M%S)"
          IMAGE_NAME="${{ env.APP_NAME }}:${IMAGE_TAG}"
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "image_name=${IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "âœ“ Image tag: ${IMAGE_TAG}"

      - name: Build Docker image
        run: |
          docker build -t ${{ steps.meta.outputs.image_name }} .
          echo "âœ… Docker image built: ${{ steps.meta.outputs.image_name }}"

      - name: Save Docker image as artifact
        run: |
          docker save ${{ steps.meta.outputs.image_name }} -o /tmp/image.tar
          echo "âœ“ Image saved to artifact"

      - name: Upload image artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: /tmp/image.tar
          retention-days: 1

  # Stage 3: Grype Vulnerability Scan
  grype-scan:
    name: "ðŸ” Grype Vulnerability Scan"
    runs-on: ubuntu-latest
    needs: [build-image]
    continue-on-error: true  # Warn mode by default for Quick Setup
    steps:
      - name: Download image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp

      - name: Load Docker image
        run: |
          docker load -i /tmp/image.tar
          echo "âœ“ Image loaded from artifact"

      - name: Run Grype scan
        uses: anchore/scan-action@v4
        id: grype
        with:
          image: ${{ needs.build-image.outputs.image_name }}
          fail-build: false
          severity-cutoff: high
          output-format: sarif

      - name: Upload Grype results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: ${{ steps.grype.outputs.sarif }}

      - name: Display scan mode
        if: always()
        run: |
          echo "âš ï¸  WARN MODE: Vulnerabilities reported but workflow continues"
          echo "To enable blocking mode, set GitHub variable GRYPE_MODE=block"

  # Stage 4: Push to ECR
  push-to-ecr:
    name: "ðŸ“¤ Push Image to ECR"
    runs-on: ubuntu-latest
    needs: [build-image, grype-scan]
    if: success() || needs.grype-scan.result == 'failure'  # Push even if scan warns
    outputs:
      ecr_uri: ${{ steps.push.outputs.ecr_uri }}
      image_tag: ${{ needs.build-image.outputs.image_tag }}
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Download image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp

      - name: Load and push to ECR
        id: push
        run: |
          # Load image
          docker load -i /tmp/image.tar

          # Get AWS account ID
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)

          # Login to ECR
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
            docker login --username AWS --password-stdin ${AWS_ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com

          # Tag for ECR
          ECR_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPO_NAME }}"
          docker tag ${{ needs.build-image.outputs.image_name }} ${ECR_URI}:${{ needs.build-image.outputs.image_tag }}

          # Push to ECR
          docker push ${ECR_URI}:${{ needs.build-image.outputs.image_tag }}

          echo "ecr_uri=${ECR_URI}" >> $GITHUB_OUTPUT
          echo "âœ… Image pushed to ECR: ${ECR_URI}:${{ needs.build-image.outputs.image_tag }}"

  # Stage 5: Update Manifests
  update-manifests:
    name: "ðŸ“ Update Kubernetes Manifests"
    runs-on: ubuntu-latest
    needs: [push-to-ecr]
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}
          fetch-depth: 0

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Update kustomization with new image tag
        run: |
          # Pull first before making changes
          git pull --rebase origin ${{ github.ref_name }}

          KUSTOMIZATION=".${{ env.TENANT }}-${{ env.APP_NAME }}/k8s/overlays/${{ env.ENVIRONMENT }}/kustomization.yaml"

          if [ ! -f "$KUSTOMIZATION" ]; then
            echo "âš ï¸ Kustomization file not found, will be created by first deployment"
            exit 0
          fi

          # Update image tag using sed
          sed -i "s|newTag:.*|newTag: ${{ needs.push-to-ecr.outputs.image_tag }}|g" "$KUSTOMIZATION"

          echo "âœ“ Updated manifest with image tag: ${{ needs.push-to-ecr.outputs.image_tag }}"

      - name: Commit and push manifest changes
        run: |
          git add .${{ env.TENANT }}-${{ env.APP_NAME }}/k8s/overlays/${{ env.ENVIRONMENT }}/

          if git diff --staged --quiet; then
            echo "No manifest changes to commit"
            exit 0
          fi

          git commit -m "chore(deploy): update ${{ env.ENVIRONMENT }} image to ${{ needs.push-to-ecr.outputs.image_tag }} [skip ci]"

          # Retry loop for push with conflict resolution
          for i in 1 2 3; do
            echo "Push attempt $i/3..."
            if git push origin ${{ github.ref_name }}; then
              echo "âœ… Manifest updated and pushed successfully"
              break
            fi

            echo "âš ï¸ Push failed, pulling latest and retrying..."
            git pull --rebase origin ${{ github.ref_name }}
            sleep 2

            if [ $i -eq 3 ]; then
              echo "âŒ Failed to push after 3 attempts"
              exit 1
            fi
          done

  # Stage 6: Create/Update ArgoCD Application (NEW in v2.1)
  create-argocd-app:
    name: "ðŸŽ¯ Create/Update ArgoCD Application"
    runs-on: ubuntu-latest
    needs: [update-manifests]
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.ref_name }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'latest'

      - name: Configure kubeconfig for hub cluster
        run: |
          aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.AWS_REGION }} --alias hub
          echo "âœ“ Configured kubeconfig for hub cluster"

      - name: Create or update ArgoCD application
        run: |
          APP_FILE=".${{ env.TENANT }}-${{ env.APP_NAME }}/argocd/${{ env.ENVIRONMENT }}/application.yaml"

          if [ -f "$APP_FILE" ]; then
            kubectl --context hub apply -f "$APP_FILE"
            kubectl --context hub get application ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} -n argocd
            echo "âœ… ArgoCD application updated"
          else
            echo "âš ï¸ ArgoCD application file not found: $APP_FILE"
            echo "Will be created when manifests are generated"
          fi

  # Stage 7: Refresh ECR Secret (SPOKE)
  refresh-ecr-secret:
    name: "ðŸ”‘ Refresh ECR Pull Secret"
    runs-on: ubuntu-latest
    needs: [create-argocd-app]
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'latest'

      - name: Configure kubeconfig for spoke cluster
        run: |
          aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.AWS_REGION }} --alias spoke

      - name: Refresh ECR pull secret
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_PASS=$(aws ecr get-login-password --region ${{ env.AWS_REGION }})

          kubectl --context spoke create secret docker-registry ecr-pull-secret \
            --docker-server="${AWS_ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com" \
            --docker-username=AWS \
            --docker-password="$ECR_PASS" \
            --namespace="${{ env.NAMESPACE }}" \
            --dry-run=client -o yaml | kubectl --context spoke apply -f -

          echo "âœ… ECR secret refreshed (valid for 12 hours)"

  # Stage 8: Sync and Deploy (HUB)
  sync-deploy:
    name: "ðŸ”„ Sync ArgoCD and Deploy"
    runs-on: ubuntu-latest
    needs: [refresh-ecr-secret, push-to-ecr]
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'latest'

      - name: Configure kubeconfig for hub cluster
        run: |
          aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.AWS_REGION }} --alias hub

      - name: Trigger ArgoCD sync
        run: |
          APP_NAME="${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}"

          # Check if application exists
          if ! kubectl --context hub get application $APP_NAME -n argocd &>/dev/null; then
            echo "âš ï¸ ArgoCD application not found: $APP_NAME"
            echo "Skipping sync - application will be created in next stage"
            exit 0
          fi

          # Hard refresh application
          kubectl --context hub patch application $APP_NAME -n argocd \
            --type merge -p '{"operation":{"initiatedBy":{"username":"github-actions"},"sync":{"revision":"HEAD"}}}'

          # Trigger sync
          kubectl --context hub patch application $APP_NAME -n argocd \
            --type merge -p '{"spec":{"syncPolicy":{"automated":null}}}'

          kubectl --context hub patch application $APP_NAME -n argocd \
            --type merge -p '{"operation":{"sync":{"revision":"HEAD","prune":true}}}'

          echo "âœ… ArgoCD sync triggered"

          # Wait for sync to complete
          echo "Waiting for sync to complete..."
          for i in {1..30}; do
            HEALTH=$(kubectl --context hub get application $APP_NAME -n argocd -o jsonpath='{.status.health.status}')
            SYNC=$(kubectl --context hub get application $APP_NAME -n argocd -o jsonpath='{.status.sync.status}')

            echo "Sync status: $SYNC, Health: $HEALTH"

            if [ "$SYNC" = "Synced" ] && [ "$HEALTH" = "Healthy" ]; then
              echo "âœ… Application synced and healthy"
              break
            fi

            if [ $i -eq 30 ]; then
              echo "âš ï¸ Sync timeout - check ArgoCD console"
              exit 1
            fi

            sleep 10
          done

  # Stage 9: Verify Deployment (SPOKE)
  verify-deployment:
    name: "âœ… Verify Deployment"
    runs-on: ubuntu-latest
    needs: [sync-deploy]
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'latest'

      - name: Configure kubeconfig for spoke cluster
        run: |
          aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.AWS_REGION }} --alias spoke

      - name: Verify pods are running
        run: |
          echo "Checking pods in namespace: ${{ env.NAMESPACE }}"

          for i in {1..12}; do
            READY_PODS=$(kubectl --context spoke get pods -n ${{ env.NAMESPACE }} -l app=${{ env.APP_NAME }} \
              -o jsonpath='{.items[*].status.conditions[?(@.type=="Ready")].status}' | grep -o "True" | wc -l)

            TOTAL_PODS=$(kubectl --context spoke get pods -n ${{ env.NAMESPACE }} -l app=${{ env.APP_NAME }} \
              --no-headers | wc -l)

            echo "Ready pods: $READY_PODS/$TOTAL_PODS"

            if [ "$READY_PODS" -gt 0 ] && [ "$READY_PODS" -eq "$TOTAL_PODS" ]; then
              echo "âœ… All pods are ready"
              kubectl --context spoke get pods -n ${{ env.NAMESPACE }} -l app=${{ env.APP_NAME }}
              break
            fi

            if [ $i -eq 12 ]; then
              echo "âŒ Pods not ready after 2 minutes"
              kubectl --context spoke get pods -n ${{ env.NAMESPACE }} -l app=${{ env.APP_NAME }}
              kubectl --context spoke describe pods -n ${{ env.NAMESPACE }} -l app=${{ env.APP_NAME }}
              exit 1
            fi

            sleep 10
          done

      - name: Check service and ingress
        run: |
          echo "Services:"
          kubectl --context spoke get svc -n ${{ env.NAMESPACE }}

          echo ""
          echo "Ingresses:"
          kubectl --context spoke get ingress -n ${{ env.NAMESPACE }}

  # Stage 10: Trigger Deployment Landscape
  trigger-landscape:
    name: "ðŸ“Š Generate Deployment Landscape"
    runs-on: ubuntu-latest
    needs: [verify-deployment, push-to-ecr]
    if: success()
    steps:
      - name: Trigger landscape workflow
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}
          script: |
            try {
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: '90-deployment-landscape-fbb11.yaml',
                ref: context.ref || 'main',
                inputs: {
                  environment: '${{ env.ENVIRONMENT }}'
                }
              });
              console.log('âœ… Deployment landscape workflow triggered for ${{ env.ENVIRONMENT }}');
            } catch (error) {
              console.log('âš ï¸ Could not trigger landscape workflow:', error.message);
              console.log('This is non-blocking - deployment succeeded');
            }

  # Deployment Summary
  deployment-summary:
    name: "ðŸ“‹ Deployment Summary"
    runs-on: ubuntu-latest
    needs: [build-image, push-to-ecr, verify-deployment]
    if: always()
    steps:
      - name: Generate summary
        run: |
          echo "# Deployment Summary - fbb11 (dev)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Image Details" >> $GITHUB_STEP_SUMMARY
          echo "- **Tag**: ${{ needs.push-to-ecr.outputs.image_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "- **ECR URI**: ${{ needs.push-to-ecr.outputs.ecr_uri }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Deployment Status" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ env.ENVIRONMENT }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Namespace**: ${{ env.NAMESPACE }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Cluster**: ${{ env.SPOKE_CLUSTER }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Verification**: ${{ needs.verify-deployment.result }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Pipeline Stages" >> $GITHUB_STEP_SUMMARY
          echo "1. Security Scan: Completed (warn mode)" >> $GITHUB_STEP_SUMMARY
          echo "2. Build Image: ${{ needs.build-image.result }}" >> $GITHUB_STEP_SUMMARY
          echo "3. Vulnerability Scan: Completed (warn mode)" >> $GITHUB_STEP_SUMMARY
          echo "4. Push to ECR: ${{ needs.push-to-ecr.result }}" >> $GITHUB_STEP_SUMMARY
          echo "5. Update Manifests: Completed" >> $GITHUB_STEP_SUMMARY
          echo "6. Create ArgoCD App: Completed" >> $GITHUB_STEP_SUMMARY
          echo "7. Refresh ECR Secret: Completed" >> $GITHUB_STEP_SUMMARY
          echo "8. Sync and Deploy: Completed" >> $GITHUB_STEP_SUMMARY
          echo "9. Verify Deployment: ${{ needs.verify-deployment.result }}" >> $GITHUB_STEP_SUMMARY
          echo "10. Deployment Landscape: Triggered" >> $GITHUB_STEP_SUMMARY
