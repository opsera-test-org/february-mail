name: "2ï¸âƒ£ CI/CD Pipeline - ffbb1 (dev)"

on:
  push:
    branches:
      - main
    paths-ignore:
      - '.opsera-**/k8s/**'
      - '**/*.md'
      - '.github/workflows/1-bootstrap-*.yaml'
      - '.github/workflows/90-deployment-landscape-*.yaml'

  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip tests'
        required: false
        default: 'false'

env:
  TENANT: "opsera"
  APP_NAME: "ffbb1"
  ENVIRONMENT: "dev"
  AWS_REGION: "us-west-2"
  HUB_CLUSTER: "argocd-usw2"
  SPOKE_CLUSTER: "opsera-usw2-np"
  ARGOCD_SERVER: "argocd-usw2.agent.opsera.dev"
  APP_FOLDER: ".opsera-ffbb1"

permissions:
  contents: write
  id-token: write
  security-events: write

concurrency:
  group: ci-${{ github.ref }}-ffbb1-dev
  cancel-in-progress: false

jobs:
  # Stage 1: Security Scan (Gitleaks)
  security-scan:
    name: "ğŸ”’ Security Scan (Gitleaks)"
    runs-on: ubuntu-latest
    continue-on-error: ${{ vars.GITLEAKS_MODE == 'warn' }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Gitleaks
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Display Scan Mode
        if: always()
        run: |
          if [ "${{ vars.GITLEAKS_MODE }}" = "warn" ]; then
            echo "âš ï¸  WARN MODE: Secrets detected but workflow continues"
          else
            echo "ğŸš« BLOCK MODE: Workflow failed due to secrets"
          fi

  # Stage 2: Build Image
  build-image:
    name: "ğŸ—ï¸  Build Docker Image"
    runs-on: ubuntu-latest
    needs: [security-scan]
    outputs:
      image_tag: ${{ steps.build.outputs.image_tag }}
    steps:
      - uses: actions/checkout@v4

      - name: Generate Image Tag
        id: build
        run: |
          IMAGE_TAG="${ENVIRONMENT}-${GITHUB_SHA:0:8}-$(date +%Y%m%d%H%M%S)"
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "Building image with tag: ${IMAGE_TAG}"

      - name: Build Docker Image (Local Only)
        run: |
          docker build -t ${APP_NAME}:${{ steps.build.outputs.image_tag }} .
          echo "âœ… Image built successfully"

      - name: Save Image as Artifact (RULE 185)
        run: |
          docker save ${APP_NAME}:${{ steps.build.outputs.image_tag }} -o /tmp/docker-image.tar
          ls -lh /tmp/docker-image.tar

      - name: Upload Image Artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: /tmp/docker-image.tar
          retention-days: 1

  # Stage 3: Grype Vulnerability Scan
  grype-scan:
    name: "ğŸ” Grype Vulnerability Scan"
    runs-on: ubuntu-latest
    needs: [build-image]
    continue-on-error: ${{ vars.GRYPE_MODE == 'warn' }}
    outputs:
      scan_passed: ${{ steps.scan.outputs.scan_passed }}
    steps:
      - name: Download Image Artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp

      - name: Load Docker Image
        run: |
          docker load -i /tmp/docker-image.tar
          docker images

      - name: Run Grype Scan
        id: scan
        uses: anchore/scan-action@v3
        with:
          image: ${{ env.APP_NAME }}:${{ needs.build-image.outputs.image_tag }}
          fail-build: ${{ vars.GRYPE_MODE == 'block' }}
          severity-cutoff: high
          output-format: sarif

      - name: Upload Scan Results
        if: always()
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: ${{ steps.scan.outputs.sarif }}

      - name: Display Scan Mode
        if: always()
        run: |
          if [ "${{ vars.GRYPE_MODE }}" = "warn" ]; then
            echo "âš ï¸  WARN MODE: Vulnerabilities detected but build continues"
            echo "scan_passed=true" >> $GITHUB_OUTPUT
          else
            echo "ğŸš« BLOCK MODE: Build fails on high/critical vulnerabilities"
            echo "scan_passed=${{ steps.scan.outcome == 'success' }}" >> $GITHUB_OUTPUT
          fi

  # Stage 4: Push to ECR
  push-to-ecr:
    name: "ğŸ“¦ Push to ECR"
    runs-on: ubuntu-latest
    needs: [build-image, grype-scan]
    if: needs.grype-scan.outputs.scan_passed == 'true' || vars.GRYPE_MODE == 'warn'
    outputs:
      ecr_uri: ${{ steps.push.outputs.ecr_uri }}
      full_image: ${{ steps.push.outputs.full_image }}
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Download Image Artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp

      - name: Load Docker Image
        run: |
          docker load -i /tmp/docker-image.tar
          docker images

      - name: Login to Amazon ECR
        run: |
          aws ecr get-login-password --region ${AWS_REGION} | \
            docker login --username AWS --password-stdin \
            $(aws sts get-caller-identity --query Account --output text).dkr.ecr.${AWS_REGION}.amazonaws.com

      - name: Push to ECR
        id: push
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${TENANT}/${APP_NAME}"
          IMAGE_TAG="${{ needs.build-image.outputs.image_tag }}"

          # Tag image for ECR
          docker tag ${APP_NAME}:${IMAGE_TAG} ${ECR_URI}:${IMAGE_TAG}

          # Push to ECR
          docker push ${ECR_URI}:${IMAGE_TAG}

          echo "ecr_uri=${ECR_URI}" >> $GITHUB_OUTPUT
          echo "full_image=${ECR_URI}:${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "âœ… Image pushed to ECR: ${ECR_URI}:${IMAGE_TAG}"

  # Stage 5: Update Manifests
  update-manifests:
    name: "ğŸ“ Update Manifests"
    runs-on: ubuntu-latest
    needs: [push-to-ecr]
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Update Kustomization with New Image (RULE 196 & 203)
        run: |
          cd "${APP_FOLDER}/k8s/overlays/${ENVIRONMENT}"

          # RULE 196: Pull FIRST before modifications
          git pull --rebase origin ${GITHUB_REF_NAME}
          echo "âœ… Pulled latest changes"

          # RULE 203: Dynamically extract image names (NOT hardcoded)
          IMAGE_NAMES=$(grep -A 100 "^images:" kustomization.yaml | grep "^  - name:" | awk '{print $3}')

          if [ -z "$IMAGE_NAMES" ]; then
            echo "âš ï¸  No images found in kustomization.yaml"
            exit 1
          fi

          # Update each image using kustomize
          for IMAGE_NAME in $IMAGE_NAMES; do
            echo "Updating: ${IMAGE_NAME} -> ${{ needs.push-to-ecr.outputs.ecr_uri }}:${{ needs.build-image.outputs.image_tag }}"
            kustomize edit set image ${IMAGE_NAME}=${{ needs.push-to-ecr.outputs.ecr_uri }}:${{ needs.build-image.outputs.image_tag }}
          done

          cd -

          cat "${APP_FOLDER}/k8s/overlays/${ENVIRONMENT}/kustomization.yaml"
          echo "âœ… Manifest updated"

      - name: Commit and Push with Retry Loop (RULE 202)
        run: |
          cd "${APP_FOLDER}/k8s/overlays/${ENVIRONMENT}"

          git add kustomization.yaml
          git commit -m "chore(deploy): update ${ENVIRONMENT} image to ${{ needs.build-image.outputs.image_tag }} [skip ci]"

          # RULE 202: Retry loop with rebase (up to 3 attempts)
          for i in 1 2 3; do
            echo "Push attempt $i/3..."
            if git push origin ${GITHUB_REF_NAME}; then
              echo "âœ… Manifest updated and pushed successfully"
              break
            fi

            echo "âš ï¸  Push failed, pulling latest and retrying..."
            git pull --rebase origin ${GITHUB_REF_NAME}
            sleep 2

            if [ $i -eq 3 ]; then
              echo "âŒ Failed to push after 3 attempts"
              exit 1
            fi
          done

  # Stage 6: Create/Update ArgoCD Application (RULE 199 - MANDATORY)
  create-argocd-app:
    name: "ğŸ”§ Create/Update ArgoCD App"
    runs-on: ubuntu-latest
    needs: [update-manifests]
    steps:
      - uses: actions/checkout@v4
        with:
          ref: main

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl Hub Context (RULE 189)
        run: |
          aws eks update-kubeconfig --name ${HUB_CLUSTER} --region ${AWS_REGION} --alias hub

      - name: Create or Update ArgoCD Application
        run: |
          kubectl --context hub apply -f ${APP_FOLDER}/argocd/${ENVIRONMENT}/application.yaml
          kubectl --context hub get application ${APP_NAME}-${ENVIRONMENT} -n argocd
          echo "âœ… ArgoCD application created/updated"

  # Stage 7: Refresh ECR Secret (SPOKE)
  refresh-ecr-secret:
    name: "ğŸ” Refresh ECR Secret (SPOKE)"
    runs-on: ubuntu-latest
    needs: [create-argocd-app, push-to-ecr]
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl Spoke Context (RULE 189)
        run: |
          aws eks update-kubeconfig --name ${SPOKE_CLUSTER} --region ${AWS_REGION} --alias spoke

      - name: Refresh ECR Pull Secret (RULE 187 & 197)
        run: |
          NS="${TENANT}-${APP_NAME}-${ENVIRONMENT}"
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)

          # RULE 197: Store password in variable, use --docker-password (NOT --docker-password-stdin)
          ECR_PASS=$(aws ecr get-login-password --region ${AWS_REGION})

          # RULE 187: Dry-run + apply pattern for idempotent secret creation
          kubectl create secret docker-registry ecr-pull-secret \
            --docker-server="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com" \
            --docker-username=AWS \
            --docker-password="$ECR_PASS" \
            --namespace="${NS}" \
            --dry-run=client -o yaml | kubectl --context spoke apply -f -

          echo "âœ… ECR secret refreshed (valid for 12 hours)"

  # Stage 8: Sync and Deploy (HUB)
  sync-and-deploy:
    name: "ğŸš€ Sync ArgoCD & Deploy"
    runs-on: ubuntu-latest
    needs: [refresh-ecr-secret]
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl Hub Context (RULE 189)
        run: |
          aws eks update-kubeconfig --name ${HUB_CLUSTER} --region ${AWS_REGION} --alias hub

      - name: Hard Refresh ArgoCD Application
        run: |
          kubectl --context hub patch application ${APP_NAME}-${ENVIRONMENT} -n argocd \
            --type merge -p '{"metadata":{"annotations":{"argocd.argoproj.io/refresh":"hard"}}}'
          echo "âœ… ArgoCD hard refresh triggered"

      - name: Trigger Sync and Wait
        run: |
          kubectl --context hub patch application ${APP_NAME}-${ENVIRONMENT} -n argocd \
            --type merge -p '{"operation":{"initiatedBy":{"username":"github-actions"},"sync":{"syncStrategy":{"hook":{}}}}}'

          echo "Waiting for sync to complete..."
          kubectl --context hub wait application/${APP_NAME}-${ENVIRONMENT} -n argocd \
            --for=condition=Synced --timeout=300s

          echo "âœ… ArgoCD sync completed"

  # Stage 9: Verify Deployment (SPOKE)
  verify-deployment:
    name: "âœ… Verify Deployment"
    runs-on: ubuntu-latest
    needs: [sync-and-deploy, push-to-ecr]
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl Spoke Context (RULE 189)
        run: |
          aws eks update-kubeconfig --name ${SPOKE_CLUSTER} --region ${AWS_REGION} --alias spoke

      - name: Wait for Deployment Rollout
        run: |
          NS="${TENANT}-${APP_NAME}-${ENVIRONMENT}"

          echo "Waiting for deployment rollout..."
          kubectl --context spoke rollout status deployment/${APP_NAME} -n ${NS} --timeout=5m

          echo "âœ… Deployment rollout completed"

      - name: Verify Pods Running
        run: |
          NS="${TENANT}-${APP_NAME}-${ENVIRONMENT}"

          echo "Checking pod status..."
          kubectl --context spoke get pods -n ${NS} -l app=${APP_NAME}

          READY_PODS=$(kubectl --context spoke get pods -n ${NS} -l app=${APP_NAME} \
            -o jsonpath='{.items[*].status.containerStatuses[0].ready}' | grep -o true | wc -l)

          if [ "$READY_PODS" -eq 0 ]; then
            echo "âŒ No pods are ready"
            exit 1
          fi

          echo "âœ… ${READY_PODS} pod(s) running and ready"

      - name: Verify Service and Ingress
        run: |
          NS="${TENANT}-${APP_NAME}-${ENVIRONMENT}"

          echo "Checking service..."
          kubectl --context spoke get svc ${APP_NAME} -n ${NS}

          echo "Checking ingress..."
          kubectl --context spoke get ingress ${APP_NAME} -n ${NS}

          echo "âœ… Service and Ingress verified"

      - name: Health Check via Port-Forward (RULE 168)
        run: |
          NS="${TENANT}-${APP_NAME}-${ENVIRONMENT}"

          POD=$(kubectl --context spoke get pods -n ${NS} -l app=${APP_NAME} -o jsonpath='{.items[0].metadata.name}')

          if [ -z "$POD" ]; then
            echo "âŒ No pods found"
            exit 1
          fi

          # Port-forward and test health
          kubectl --context spoke port-forward $POD 8081:8080 -n ${NS} &
          PF_PID=$!
          sleep 3

          if wget -qO- http://localhost:8081/ > /dev/null 2>&1; then
            echo "âœ… Health check passed"
          else
            echo "âš ï¸  Health check warning (may be SPA redirect)"
          fi

          kill $PF_PID 2>/dev/null || true

  # Stage 10: Deployment Landscape (RULE 201 - MANDATORY)
  trigger-landscape:
    name: "ğŸ“Š Generate Deployment Landscape"
    runs-on: ubuntu-latest
    needs: [verify-deployment]
    if: success()
    steps:
      - name: Trigger Landscape Workflow
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}
          script: |
            try {
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: '90-deployment-landscape-ffbb1.yaml',
                ref: context.ref || 'main',
                inputs: {
                  environment: '${{ env.ENVIRONMENT }}'
                }
              });
              console.log('âœ… Deployment landscape workflow triggered for ${{ env.ENVIRONMENT }}');
            } catch (error) {
              console.log('âš ï¸  Could not trigger landscape workflow:', error.message);
              console.log('This is non-blocking - deployment succeeded');
            }

  deployment-summary:
    name: "ğŸ“‹ Deployment Summary"
    runs-on: ubuntu-latest
    needs: [build-image, push-to-ecr, verify-deployment]
    if: always()
    steps:
      - name: Summary
        run: |
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘              DEPLOYMENT SUMMARY - ffbb1 (dev)                   â•‘"
          echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
          echo "â•‘  Environment: ${ENVIRONMENT}"
          echo "â•‘  Image Tag: ${{ needs.build-image.outputs.image_tag }}"
          echo "â•‘  ECR URI: ${{ needs.push-to-ecr.outputs.ecr_uri }}"
          echo "â•‘  Namespace: ${TENANT}-${APP_NAME}-${ENVIRONMENT}"
          echo "â•‘  Cluster: ${SPOKE_CLUSTER}"
          echo "â•‘"
          echo "â•‘  Status: ${{ needs.verify-deployment.result }}"
          echo "â•‘"
          echo "â•‘  Application URL:"
          echo "â•‘  https://ffbb1-dev.agent.opsera.dev"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
