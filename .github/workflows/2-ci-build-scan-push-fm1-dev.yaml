name: "ðŸš€ CI/CD Pipeline - fm1 (dev)"

# Enhanced 10-Stage Pipeline (v2.0)
# Triggered on push to main branch
# Target environment: dev

on:
  push:
    branches: [main]
    paths-ignore:
      - '.opsera-**/k8s/**'
      - '1-bootstrap-*.yaml'
      - '**/*.md'
      - '.github/workflows/*.yaml'

  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even if no code changes'
        required: false
        default: 'false'

# Prevent duplicate workflows (RULE 188)
concurrency:
  group: ci-${{ github.ref }}-fm1-dev
  cancel-in-progress: false

env:
  APP_NAME: "fm1"
  TENANT: "opsera"
  ENV: "dev"
  AWS_REGION: "us-west-2"
  REGION_SHORT: "usw2"
  HUB_CLUSTER: "argocd-usw2"
  SPOKE_CLUSTER: "opsera-usw2-np"
  NAMESPACE: "opsera-fm1-dev"
  ARGOCD_SERVER: "argocd-usw2.agent.opsera.dev"
  DOMAIN: "agent.opsera.dev"

jobs:
  # ============================================================================
  # STAGE 1: SECURITY SCAN (Gitleaks - Secrets Detection)
  # ============================================================================
  security-scan:
    name: "ðŸ”’ Stage 1: Security Scan (Gitleaks)"
    runs-on: ubuntu-latest
    # RULE 195: Job-level continue-on-error based on GitHub variable
    continue-on-error: ${{ vars.GITLEAKS_MODE == 'warn' }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for secret scanning

      - name: Run Gitleaks Scan
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Display Scan Mode
        if: always()
        run: |
          echo "### ðŸ”’ Security Scan Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ vars.GITLEAKS_MODE }}" = "warn" ]; then
            echo "âš ï¸  **WARN MODE**: Secrets detected but workflow continues" >> $GITHUB_STEP_SUMMARY
          else
            echo "ðŸš« **BLOCK MODE**: Workflow fails if secrets detected" >> $GITHUB_STEP_SUMMARY
          fi

  # ============================================================================
  # STAGE 2: BUILD IMAGE (Docker Build - Local Only)
  # ============================================================================
  build-image:
    name: "ðŸ—ï¸ Stage 2: Build Docker Image"
    needs: [security-scan]
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.tag.outputs.image_tag }}
      short_sha: ${{ steps.tag.outputs.short_sha }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Generate Image Tag
        id: tag
        run: |
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-8)
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          IMAGE_TAG="${ENV}-${SHORT_SHA}-${TIMESTAMP}"
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "short_sha=${SHORT_SHA}" >> $GITHUB_OUTPUT
          echo "### ðŸ·ï¸ Image Tag" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "\`${IMAGE_TAG}\`" >> $GITHUB_STEP_SUMMARY

      - name: Build Docker Image (No Push)
        run: |
          docker build \
            -t ${APP_NAME}:${{ steps.tag.outputs.image_tag }} \
            -t ${APP_NAME}:latest \
            .
          echo "âœ… Image built successfully"

      - name: Save Docker Image to Artifact (RULE 185)
        run: |
          docker save ${APP_NAME}:${{ steps.tag.outputs.image_tag }} -o /tmp/image.tar
          echo "âœ… Image saved to artifact"

      - name: Upload Docker Image Artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: /tmp/image.tar
          retention-days: 1

  # ============================================================================
  # STAGE 3: GRYPE SCAN (Vulnerability Scanning)
  # ============================================================================
  grype-scan:
    name: "ðŸ” Stage 3: Grype Vulnerability Scan"
    needs: [build-image]
    runs-on: ubuntu-latest
    # RULE 195: Job-level continue-on-error based on GitHub variable
    continue-on-error: ${{ vars.GRYPE_MODE == 'warn' }}
    outputs:
      scan_passed: ${{ steps.scan.outputs.scan_passed }}

    steps:
      - name: Download Docker Image Artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image

      - name: Load Docker Image
        run: |
          docker load -i image.tar
          echo "âœ… Image loaded from artifact"

      - name: Install Grype
        run: |
          curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b /usr/local/bin

      - name: Run Grype Scan
        id: scan
        run: |
          echo "### ðŸ” Vulnerability Scan" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Run Grype scan
          grype ${APP_NAME}:${{ needs.build-image.outputs.image_tag }} \
            --fail-on high \
            --output table \
            | tee grype-report.txt

          # Check scan result
          if [ $? -eq 0 ]; then
            echo "scan_passed=true" >> $GITHUB_OUTPUT
            echo "âœ… **PASSED**: No critical vulnerabilities" >> $GITHUB_STEP_SUMMARY
          else
            echo "scan_passed=false" >> $GITHUB_OUTPUT
            if [ "${{ vars.GRYPE_MODE }}" = "warn" ]; then
              echo "âš ï¸  **WARN MODE**: Vulnerabilities found but continuing" >> $GITHUB_STEP_SUMMARY
            else
              echo "âŒ **BLOCK MODE**: Vulnerabilities found, workflow failed" >> $GITHUB_STEP_SUMMARY
            fi
          fi

      - name: Generate Grype Reports
        if: always()
        run: |
          # JSON report
          grype ${APP_NAME}:${{ needs.build-image.outputs.image_tag }} \
            --output json > grype-report.json

          # SARIF report for GitHub Security
          grype ${APP_NAME}:${{ needs.build-image.outputs.image_tag }} \
            --output sarif > grype-report.sarif

      - name: Upload Grype Reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: grype-reports
          path: |
            grype-report.txt
            grype-report.json
            grype-report.sarif
          retention-days: 30

      - name: Upload SARIF to GitHub Security
        if: always()
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: grype-report.sarif

  # ============================================================================
  # STAGE 4: PUSH TO ECR (Only if scan passed or warn mode)
  # ============================================================================
  push-to-ecr:
    name: "ðŸ“¤ Stage 4: Push to ECR"
    needs: [build-image, grype-scan]
    if: needs.grype-scan.outputs.scan_passed == 'true' || vars.GRYPE_MODE == 'warn'
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    outputs:
      ecr_uri: ${{ steps.push.outputs.ecr_uri }}
      image_tag: ${{ needs.build-image.outputs.image_tag }}

    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Download Docker Image Artifact (RULE 185)
        uses: actions/download-artifact@v4
        with:
          name: docker-image

      - name: Load Docker Image
        run: |
          docker load -i image.tar
          echo "âœ… Image loaded from artifact"

      - name: Login to Amazon ECR
        run: |
          aws ecr get-login-password --region ${AWS_REGION} | \
            docker login --username AWS --password-stdin \
            $(aws sts get-caller-identity --query Account --output text).dkr.ecr.${AWS_REGION}.amazonaws.com

      - name: Push to ECR
        id: push
        run: |
          # Get AWS Account ID dynamically (RULE 147)
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/opsera/${APP_NAME}"

          # Tag for ECR
          docker tag ${APP_NAME}:${{ needs.build-image.outputs.image_tag }} \
            ${ECR_URI}:${{ needs.build-image.outputs.image_tag }}

          # Push to ECR
          docker push ${ECR_URI}:${{ needs.build-image.outputs.image_tag }}

          echo "ecr_uri=${ECR_URI}" >> $GITHUB_OUTPUT
          echo "âœ… Image pushed to ECR"

          # Summary
          echo "### ðŸ“¤ ECR Push" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- Registry: \`${ECR_URI}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Tag: \`${{ needs.build-image.outputs.image_tag }}\`" >> $GITHUB_STEP_SUMMARY

  # ============================================================================
  # STAGE 5: UPDATE MANIFESTS (Kustomize Image Transformer)
  # ============================================================================
  update-manifests:
    name: "ðŸ“ Stage 5: Update Manifests"
    needs: [push-to-ecr]
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Update Kustomization (RULE 196 - Pull FIRST!)
        run: |
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # RULE 196: Pull FIRST (before any modifications)
          git pull --rebase origin ${{ github.ref_name }}
          echo "âœ… Pulled latest changes"

          # Now safe to modify files
          KUSTOMIZATION=".opsera-${APP_NAME}/k8s/overlays/${ENV}/kustomization.yaml"
          IMAGE_TAG="${{ needs.push-to-ecr.outputs.image_tag }}"
          ECR_URI="${{ needs.push-to-ecr.outputs.ecr_uri }}"

          # Update Kustomize overlay with real ECR URI and tag (RULE 194)
          sed -i "s|newName:.*|newName: ${ECR_URI}|g" "$KUSTOMIZATION"
          sed -i "s|newTag:.*|newTag: ${IMAGE_TAG}|g" "$KUSTOMIZATION"

          echo "âœ… Updated overlay with ECR URI and tag"

          # Stage, commit, push
          git add "$KUSTOMIZATION"
          git commit -m "chore(deploy): update ${ENV} image to ${IMAGE_TAG} [skip ci]"
          git push origin ${{ github.ref_name }}

          echo "### ðŸ“ Manifest Update" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- File: \`${KUSTOMIZATION}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Image: \`${ECR_URI}:${IMAGE_TAG}\`" >> $GITHUB_STEP_SUMMARY

  # ============================================================================
  # STAGE 6: REFRESH ECR SECRET (SPOKE - Before ArgoCD Sync!)
  # ============================================================================
  refresh-ecr-secret:
    name: "ðŸ” Stage 6: Refresh ECR Secret (SPOKE)"
    needs: [push-to-ecr, update-manifests]
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Kubeconfig (Spoke)
        run: |
          aws eks update-kubeconfig \
            --name ${SPOKE_CLUSTER} \
            --region ${AWS_REGION} \
            --alias spoke
          echo "âœ… Spoke cluster kubeconfig configured"

      - name: Refresh ECR Pull Secret (RULE 187, RULE 197)
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_SERVER="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"

          # Get ECR password (RULE 197 - use variable, NOT stdin)
          ECR_PASS=$(aws ecr get-login-password --region ${AWS_REGION})

          # Create or update secret (RULE 187 - dry-run + apply pattern)
          kubectl create secret docker-registry ecr-pull-secret \
            --docker-server="${ECR_SERVER}" \
            --docker-username=AWS \
            --docker-password="$ECR_PASS" \
            --namespace="${NAMESPACE}" \
            --dry-run=client -o yaml | kubectl --context spoke apply -f -

          echo "âœ… ECR secret refreshed (valid for 12 hours)"

  # ============================================================================
  # STAGE 7: CREATE/UPDATE ARGOCD APPLICATION (v2.1 - Idempotent - RULE 199)
  # ============================================================================
  create-argocd-app:
    name: "ðŸŽ¯ Stage 7: Create/Update ArgoCD App"
    needs: [update-manifests]
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Kubeconfig (Hub)
        run: |
          aws eks update-kubeconfig \
            --name ${HUB_CLUSTER} \
            --region ${AWS_REGION} \
            --alias hub
          echo "âœ… Hub cluster kubeconfig configured"

      - name: Create or Update ArgoCD Application (Idempotent)
        run: |
          APP_NAME_ENV="${APP_NAME}-${ENV}"

          # Check if application exists
          if kubectl --context hub get application ${APP_NAME_ENV} -n argocd &>/dev/null; then
            echo "âœ… ArgoCD application already exists: ${APP_NAME_ENV}"
          else
            echo "Creating ArgoCD application: ${APP_NAME_ENV}"

            cat <<EOF | kubectl --context hub apply -f -
            apiVersion: argoproj.io/v1alpha1
            kind: Application
            metadata:
              name: ${APP_NAME_ENV}
              namespace: argocd
              finalizers:
                - resources-finalizer.argocd.argoproj.io
            spec:
              project: default
              source:
                repoURL: https://github.com/${{ github.repository }}.git
                targetRevision: ${{ github.ref_name }}
                path: .opsera-${APP_NAME}/k8s/overlays/${ENV}
              destination:
                name: ${SPOKE_CLUSTER}
                namespace: ${NAMESPACE}
              syncPolicy:
                automated:
                  prune: true
                  selfHeal: true
                syncOptions:
                  - CreateNamespace=true
                  - Replace=true
                retry:
                  limit: 5
                  backoff:
                    duration: 5s
                    factor: 2
                    maxDuration: 3m
          EOF

            echo "âœ… ArgoCD application created: ${APP_NAME_ENV}"
          fi

  # ============================================================================
  # STAGE 8: ARGOCD HARD REFRESH (HUB - Notify ArgoCD)
  # ============================================================================
  argocd-refresh:
    name: "ðŸ”„ Stage 8: ArgoCD Hard Refresh"
    needs: [create-argocd-app, refresh-ecr-secret]
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Kubeconfig (Hub)
        run: |
          aws eks update-kubeconfig \
            --name ${HUB_CLUSTER} \
            --region ${AWS_REGION} \
            --alias hub

      - name: Hard Refresh ArgoCD Application
        run: |
          APP_NAME_ENV="${APP_NAME}-${ENV}"

          # Trigger hard refresh
          kubectl --context hub patch application ${APP_NAME_ENV} \
            -n argocd \
            --type merge \
            -p '{"operation":{"initiatedBy":{"username":"github-actions"},"info":[{"name":"Reason","value":"Force refresh after manifest update"}]}}'

          kubectl --context hub -n argocd patch app ${APP_NAME_ENV} \
            --type merge \
            -p '{"metadata":{"annotations":{"argocd.argoproj.io/refresh":"hard"}}}'

          echo "âœ… ArgoCD hard refresh triggered"

  # ============================================================================
  # STAGE 9: ARGOCD SYNC (HUB - Trigger and Wait)
  # ============================================================================
  argocd-sync:
    name: "âš¡ Stage 9: ArgoCD Sync"
    needs: [argocd-refresh]
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Kubeconfig (Hub)
        run: |
          aws eks update-kubeconfig \
            --name ${HUB_CLUSTER} \
            --region ${AWS_REGION} \
            --alias hub

      - name: Trigger ArgoCD Sync
        run: |
          APP_NAME_ENV="${APP_NAME}-${ENV}"

          # Trigger sync operation
          kubectl --context hub -n argocd patch app ${APP_NAME_ENV} \
            --type merge \
            -p '{"operation":{"sync":{"syncStrategy":{"hook":{},"apply":{"force":true}}}}}'

          echo "âœ… ArgoCD sync triggered"

      - name: Wait for Sync Completion
        run: |
          APP_NAME_ENV="${APP_NAME}-${ENV}"

          echo "Waiting for sync to complete (max 5 minutes)..."
          for i in {1..30}; do
            SYNC_STATUS=$(kubectl --context hub get application ${APP_NAME_ENV} -n argocd \
              -o jsonpath='{.status.sync.status}')
            HEALTH_STATUS=$(kubectl --context hub get application ${APP_NAME_ENV} -n argocd \
              -o jsonpath='{.status.health.status}')

            echo "Attempt $i/30: Sync=${SYNC_STATUS}, Health=${HEALTH_STATUS}"

            if [ "$SYNC_STATUS" = "Synced" ] && [ "$HEALTH_STATUS" = "Healthy" ]; then
              echo "âœ… Application synced and healthy"
              exit 0
            fi

            sleep 10
          done

          echo "âš ï¸  Sync did not complete in 5 minutes, proceeding to verification"

  # ============================================================================
  # STAGE 10: VERIFY DEPLOYMENT (SPOKE - Health Checks)
  # ============================================================================
  verify-deployment:
    name: "âœ… Stage 10: Verify Deployment"
    needs: [argocd-sync, push-to-ecr]
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Kubeconfig (Spoke)
        run: |
          aws eks update-kubeconfig \
            --name ${SPOKE_CLUSTER} \
            --region ${AWS_REGION} \
            --alias spoke

      - name: Verify Pods Running
        run: |
          echo "Checking pods in namespace ${NAMESPACE}..."

          for i in {1..12}; do
            RUNNING_PODS=$(kubectl --context spoke get pods -n ${NAMESPACE} \
              -l app=${APP_NAME} \
              --field-selector=status.phase=Running \
              --no-headers | wc -l)

            echo "Attempt $i/12: ${RUNNING_PODS} pods running"

            if [ "$RUNNING_PODS" -ge 2 ]; then
              echo "âœ… Pods are running"
              kubectl --context spoke get pods -n ${NAMESPACE} -l app=${APP_NAME}
              exit 0
            fi

            sleep 10
          done

          echo "âŒ Pods not running after 2 minutes"
          kubectl --context spoke get pods -n ${NAMESPACE} -l app=${APP_NAME}
          exit 1

      - name: Verify Deployment Rollout
        run: |
          kubectl --context spoke rollout status deployment/${APP_NAME} \
            -n ${NAMESPACE} \
            --timeout=3m
          echo "âœ… Deployment rollout complete"

      - name: Verify Service
        run: |
          kubectl --context spoke get service ${APP_NAME} -n ${NAMESPACE}
          echo "âœ… Service verified"

      - name: Verify Ingress
        run: |
          kubectl --context spoke get ingress ${APP_NAME} -n ${NAMESPACE}
          echo "âœ… Ingress verified"

      - name: Deployment Summary
        run: |
          echo "# ðŸŽ‰ Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Environment: **${ENV}**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Application**: \`${APP_NAME}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Namespace**: \`${NAMESPACE}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Image Tag**: \`${{ needs.push-to-ecr.outputs.image_tag }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **ECR URI**: \`${{ needs.push-to-ecr.outputs.ecr_uri }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **URL**: https://${APP_NAME}-${ENV}.${DOMAIN}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Pipeline Stages Completed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Stage 1: Security Scan (Gitleaks)" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Stage 2: Build Docker Image" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Stage 3: Grype Vulnerability Scan" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Stage 4: Push to ECR" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Stage 5: Update Manifests" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Stage 6: Refresh ECR Secret (SPOKE)" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Stage 7: Create/Update ArgoCD App (HUB)" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Stage 8: ArgoCD Hard Refresh (HUB)" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Stage 9: ArgoCD Sync (HUB)" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Stage 10: Verify Deployment (SPOKE)" >> $GITHUB_STEP_SUMMARY
